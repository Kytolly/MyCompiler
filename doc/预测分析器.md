预测分析法 (LL(1)) 的核心思想
LL(1) 解析器是一种自顶向下的解析器。它的工作原理是根据当前的输入符号（lookahead）和一个非终结符，预测应该应用哪个产生式规则。这里的 "(1)" 表示解析器只需要向前看一个输入符号。
预测分析器通常由以下几个部分组成：
输入缓冲区：存储待解析的输入符号流。
解析栈：存储期望匹配的终结符和待展开的非终结符。栈底通常是输入结束标记 $，栈顶是当前需要处理的符号。
解析表 (Parsing Table)：一个二维表 M[A, t]，其中 A 是一个非终结符，t 是一个终结符（或输入结束标记 $）。表项 M[A, t] 存储当栈顶是非终结符 A 且当前输入符号是 t 时，应该应用的产生式 A -> \beta。
输出流：生成语法分析树或执行相应的语义动作。
FIRST集和FOLLOW集在构建解析表中的作用
构建预测分析表 M 是关键步骤，它依赖于文法的 FIRST 集和 FOLLOW 集。
FIRST(α)：对于一个文法符号串 α，FIRST(α) 是可以由 α 推导出的所有可能的终结符的集合（如果 α 可以推导出 ε，那么 ε 也在 FIRST(α) 中）。
FOLLOW(A)：对于一个非终结符 A，FOLLOW(A) 是在某个句型中紧跟在 A 后面的所有终结符的集合（如果 A 是句型的最后一个符号，那么输入结束标记 $ 在 FOLLOW(A) 中）。
构建解析表的规则：
对于文法中的每个产生式 A -> α：
对于 FIRST(α) 中的每个终结符 t，将产生式 A -> α 添加到 M[A, t] 中。
如果 ε 在 FIRST(α) 中（即 α 可以推导出 ε）：
对于 FOLLOW(A) 中的每个终结符 t，将产生式 A -> ε 添加到 M[A, t] 中。
如果 $ 在 FOLLOW(A) 中，将产生式 A -> ε 添加到 M[A, $] 中。
如果一个表项 M[A, t] 被填充了多于一个产生式，那么这个文法就不是 LL(1) 文法，不能用简单的预测分析器进行解析。我们的文法因为通过了LL(1)测试，所以每个表项最多只有一个产生式。
预测分析器的工作流程：
解析器从初始状态开始，栈中放入起始非终结符和 $，输入缓冲区是待解析的 token 流后跟 $。解析器重复以下步骤直到栈顶和输入符号都为 $：
设 X 是栈顶符号，a 是当前输入符号。
如果 X 是一个终结符：
如果 X == a：从栈中弹出 X，将输入指针前移一个符号（advance()）。
如果 X != a：发生语法错误。
如果 X 是一个非终结符：
查找解析表 M[X, a]。
如果表项为空或表示错误：发生语法错误。
如果表项是产生式 X -> \beta：
将 X 从栈中弹出。
将 \beta 的符号从右到左压入栈中（如果 \beta 是 ε，则什么也不压入）。这相当于将非终结符 X 展开为其产生式右部的符号串。
如果 \beta 是 ε，不要移动输入指针（不要调用 advance()）。
parse_node_* 函数如何模拟这个过程
您代码中的每一个 fn parse_node_*(...) 函数实际上都在模拟解析表中对应非终结符的解析逻辑。
例如，对于非终结符 A 和它的产生式 A -> \beta_1 | \beta_2 | ...：
fn parse_node_A(&mut self) -> Result<(), ErrorMessage> 函数会：
查看当前输入符号 self.current_token() (a)。
根据 a 和 A 的 FIRST/FOLLOW 集关系，决定应用哪个产生式（\beta_i）。这通常通过 match self.current_token() 或 if self.match_token(...) 来实现。
如果决定应用 A -> \beta_i：
它会按顺序调用相应的函数或匹配终结符来解析 \beta_i 中的符号。
匹配到终结符时，会调用 self.advance() 来消费输入符号。
调用 parse_node_B() 函数来解析非终结符 B。
如果当前输入符号 a 不在任何一个可以由 A 推导出的产生式（包括 ε 产生式由 FOLLOW 集引导）的 FIRST 集中，或者 M[A, a] 为空，函数就会报告语法错误。
ε 产生式的处理
当一个非终结符 A 可以推导出 ε (A -> ε) 时，解析表会在 M[A, t] (对于所有 t 在 FOLLOW(A) 中) 包含 A -> ε。在解析器中，这意味着当栈顶是 A 且当前输入符号 a 在 FOLLOW(A) 中时，解析器会选择 A -> ε 产生式。它会从栈中弹出 A，但不向栈中压入任何符号（因为右部是空的），并且不会移动输入指针 (advance())。这是关键！当前输入符号 a 仍然是当前的 lookahead，它将用于决定栈中下一个符号的解析。
在您的 parse_node_declaration_statement_table_prime 函数中，当 current_token() 不是 ; 并且是 end 时，它返回 Ok(()) 并没有调用 self.advance()，这正是模拟了 LL(1) 解析器选择 ε 产生式时不消费输入符号的行为。
总结：
LL(1) 解析器通过构建并查阅解析表来实现预测分析。构建解析表依赖于文法的 FIRST 集和 FOLLOW 集。