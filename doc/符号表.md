符号表是一个数据结构，用于存储程序中标识符（如变量名、函数名）的信息，包括它们的类型、作用域、内存地址等。由于编程语言通常支持嵌套的作用域（例如函数内部的变量只在该函数内部可见，块级作用域等），编译器需要一种方式来管理这些分层的可见性。
符号表栈就是为此目的而设计的。它是一个栈结构，栈的每一层代表一个作用域。
当进入一个新的作用域（例如进入一个 begin...end 块、一个函数体）时，编译器会创建一个新的符号表并将其压入栈顶。这个新的符号表用于存储该作用域内声明的标识符。
当查找一个标识符时，编译器会从栈顶（当前作用域）开始向下查找。如果在当前作用域找到，就使用该信息。如果在当前作用域找不到，就到下一层（父作用域）查找，依此类推，直到找到标识符或到达栈底。这种查找机制自然地实现了作用域的嵌套规则（内层作用域可以访问外层作用域的变量，但不能反过来；内层作用域的声明会“遮蔽”外层作用域的同名声明）。
当退出一个作用域时，编译器会将栈顶的符号表弹出。这意味着该作用域内声明的标识符不再可见。

符号表作为一个独立的模块
在主流编译器设计中，符号表系统通常被设计为一个独立的模块或服务。这个模块负责：
管理符号表的创建、销毁（对应作用域的进入和退出）。
在当前活动的作用域中添加新的标识符条目（对应变量、函数等的声明）。
在当前及外层作用域中查找标识符（对应变量使用、函数调用等）。
存储和管理与标识符相关的各种信息（类型、作用域级别、内存地址/偏移量、参数信息等）。
Parser 如何与符号表交互？
虽然符号表系统是独立的，但解析器在识别到语法结构（如 begin, end, integer identifier;, function ...）时，需要触发符号表模块的操作。也就是说，解析器是用户，符号表系统是服务。
Parser 不拥有符号表栈，但它会持有一个对符号表系统的引用或指针（在 Rust 中通常是可变引用 &mut）。当解析器识别到需要进行符号表操作的语法点时，它会调用符号表系统提供的方法：

进入新的作用域： 当解析器进入一个会创建新作用域的语法结构时。
退出当前作用域： 当解析器离开一个作用域时。
处理声明： 当解析器识别出变量或函数的声明时，需要将这些标识符添加到当前作用域的符号表中。
处理标识符的使用： 当解析器识别出标识符被用作变量、函数调用、读写目标等时，需要查找符号表以确认其存在和属性（这是一个语义分析步骤，但通常与解析紧密集成）。
用于文法如下：
<程序> → <分程序>，
<分程序> → begin <说明语句表> <执行语句表> end